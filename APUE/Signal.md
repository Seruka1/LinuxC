# 并发
**同步与异步**  
异步事件的处理：查询法，通知法 

## 信号
### 1. 信号的概念
  信号是软件中断。  
  信号的响应依赖于中断。
### 2. signal()
  `void (*signal(int signum,void(*func)(int)))(int);`  
  信号会打断阻塞的系统调用
### 3. 信号的不可靠
### 4. 可重入函数 
  第一次调用还未结束时发生了第二次调用但不会出错的函数
  所有系统调用都是可重入了，一部分系统调用可重入，如：
- memcpy
### 5. 信号的响应过程(P66)
  进程中有mask与pending  
  **信号只有从内核态到用户态的切换中才会被响应（需要中断）**   
  信号从收到到响应有一个不可避免的延迟  
  思考：如何忽略掉一个信号的？(mask对应位置0)  标准信号为什么丢失？（pending位一次性来一堆1也只能置1次）  
  **标准信号的响应没有严格的顺序**

### 6. 常用函数
- `kill()`
- `raise()`，给自己发信号
- `alarm()`,alarm会覆盖先前的alarm，信号默认杀死进程，**sleep与alarm不能混用**
  - 使用单一计时器，构造一组函数，实现任意数量的计时器
- `setitimer()`提供更精细的计时
- `pause()`
- `abort()`
- `system()`
- `sleep()`,ubuntu中等于nanosleep
- `usleep()`
- `select()`
### 7. 信号集
### 8. 信号屏蔽字/pengding集的处理
### 9. 扩展
- `sigsuspend()`
- `sigaction()`
- `setitimer()`
### 10. 实时信号

## 线程